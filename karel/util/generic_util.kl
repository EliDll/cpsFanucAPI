ROUTINE BOOL_TO_STR(input_bool: BOOLEAN): STRING
BEGIN
	-- serialize booleans as c-like integers (can be casted in most languages)
	IF(input_bool) THEN
		RETURN ('1')
	ELSE
		RETURN ('0')
	ENDIF
END BOOL_TO_STR

ROUTINE STR_TO_BOOL(input_str: STRING): BOOLEAN
BEGIN
	IF((STR_LEN(input_str) = 1) AND (input_str = '1')) THEN
		RETURN (TRUE)
	ELSE
		-- all invalid input strings are treated as false
		RETURN (FALSE)
	ENDIF
END STR_TO_BOOL

ROUTINE REAL_TO_STR(input_real: REAL) : STRING
VAR
    buffer : STRING[16]
BEGIN
    CNV_REAL_STR(input_real,8,8, buffer)
    -- remove leading blank
    RETURN (SUB_STR(buffer, 2, 254))
END REAL_TO_STR

ROUTINE REAL_ALMOST_EQUAL(first_real: REAL; second_real: REAL; margin: REAL): BOOLEAN
BEGIN
	IF ((ABS(first_real - second_real)) <= margin) THEN
		RETURN (TRUE)
	ELSE
		RETURN (FALSE)
	ENDIF
END REAL_ALMOST_EQUAL

ROUTINE XYZWPR_ALMOST_EQUAL(first_pos: XYZWPR; second_pos: XYZWPR; margin: REAL): BOOLEAN
BEGIN
	IF(	REAL_ALMOST_EQUAL(first_pos.x, second_pos.x, margin) AND
		REAL_ALMOST_EQUAL(first_pos.y, second_pos.y, margin) AND
		REAL_ALMOST_EQUAL(first_pos.z, second_pos.z, margin) AND
		REAL_ALMOST_EQUAL(first_pos.w, second_pos.w, margin) AND
		REAL_ALMOST_EQUAL(first_pos.p, second_pos.p, margin) AND
		REAL_ALMOST_EQUAL(first_pos.r, second_pos.r, margin))THEN
			RETURN (TRUE)
	ELSE
		RETURN(FALSE)
	ENDIF
END XYZWPR_ALMOST_EQUAL