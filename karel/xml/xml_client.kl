PROGRAM xml_client

%NOLOCKGROUP
%NOPAUSE=ERROR+COMMAND+TPENABLE
%NOBUSYLAMP

	%INCLUDE ../types
	%INCLUDE klerxmlf


CONST
	-- mandatory global declarations
	PROGRAM_NAME = 'xml_client'
	BUFFER_NAME = 'bufferStruct' -- global ID of var below
	pipe_path = 'PIP:pipe.dt'
	CONNECTION_TAG = 'C3:'
	
	relative_pos = FALSE
	
	PR_XYZWPR = 41
	
	R_COORD1 = 51
	R_COORD2 = 52
	R_COORD3 = 53
	R_COORD4 = 54
	R_COORD5 = 55
	R_COORD6 = 56

VAR
	bufferStruct: picking_point_t -- buffer for xml_scan, that needs static variable name as parameter
	structs: ARRAY [16] OF picking_point_t
	-- mandatory global declarations
	STATUS: INTEGER

	--file declarations must be global, declare socket file for REST calls here
	socketFile: FILE
	
	--output file for REST calls
	pipeFile: FILE
	
	log: FILE
	timeLog: FILE
	i: INTEGER
	j: INTEGER
	n: INTEGER
	timeRTT: INTEGER
	timeXML: INTEGER
	k: INTEGER
	
	current_pos: XYZWPR
		new_pos: XYZWPR
	
	query_keys: ARRAY[8] OF STRING[32]
	query_values: ARRAY[8] OF STRING[32]
	query: STRING[254]
	
ROUTINE set_reg_ : INTEGER FROM xml_client
	
--standalone imports
%INCLUDE ../util/log_util
%INCLUDE ../util/generic_util

-- requires log_util
%INCLUDE ../util/socket_util
%INCLUDE ../util/file_util
%INCLUDE ../util/stopwatch_util

-- requires socket_util, file_util
%INCLUDE ../util/rest_util

%INCLUDE obj_list_parser
%INCLUDE pp_list_parser

BEGIN
initLog('MC:log.txt')
logText('Client BEGIN')
DISCONNECT_FROM_SERVER(CONNECTION_TAG, socketFile) -- if previous execution was faulty

OPEN FILE timeLog('RW', 'MC:timeLog.txt')

	ABORT_TASK('motion', TRUE, TRUE, STATUS)
	RUN_TASK( 'motion', 1, FALSE, TRUE, 1 OR 2 OR 4, STATUS )

FOR j = 1 TO 1 DO

	START_TIME(timeRTT)
	
	current_pos = CURPOS(0,0)
	
	query_keys[1] = 'obj_id'
	query_keys[2] = 'relative'
	query_keys[3] = 'x'
	query_keys[4] = 'y'
	query_keys[5] = 'z'
	query_keys[6] = 'w'
	query_keys[7] = 'p'
	query_keys[8] = 'r'
	
	query_values[1] = '0'
	query_values[2] = BOOL_TO_STR(relative_pos)
	query_values[3] = REAL_TO_STR(current_pos.x)
	query_values[4] = REAL_TO_STR(current_pos.y)
	query_values[5] = REAL_TO_STR(current_pos.z)
	query_values[6] = REAL_TO_STR(current_pos.w)
	query_values[7] = REAL_TO_STR(current_pos.p)
	query_values[8] = REAL_TO_STR(current_pos.r)
	
	-- 'GET /picking-points?obj_id=0&relative=0&x=0&y=0&z=0&w=0&p=0&r=0'
	query = BUILD_PARAM_REQUEST('GET', 'fieldview/picking-points', query_keys, query_values)
	
	MAKE_REST_CALL(query,CONNECTION_TAG, socketFile, pipeFile, pipe_path)
	
	WRITE timeLog('RTT:', STOP_TIME(timeRTT), CR)
	
	START_TIME(timeXML)
	
	--n = parse_varlist(pipeFile, pipe_path, bufferStruct, structs)
	--n = parse_obj_list(pipeFile, pipe_path, bufferStruct, BUFFER_NAME, PROGRAM_NAME, structs)
	n = PARSE_PP_LIST(pipeFile, pipe_path, bufferStruct, BUFFER_NAME, PROGRAM_NAME, structs)
	WRITE timeLog('XML Parse:',  STOP_TIME(timeXML), CR)
	
	new_pos = current_pos --Keep the current configuration

	new_pos.x =  structs[1].x
	new_pos.y =  structs[1].y
	new_pos.z = structs[1].z
	new_pos.w = structs[1].w
	new_pos.p = structs[1].p
	new_pos.r = structs[1].r
	
	SET_POS_REG(PR_XYZWPR, new_pos, STATUS)	-- set positions register	
	IF (STATUS <> 0 ) THEN		
		WRITE log ( '{"result":"failed", "program":"appmove", "reason":',STATUS,'}')	
	ELSE
		WRITE log ( '{"result":"success", "program":"appmove", "reason":',STATUS,'}')
		FLG[4] = ON						
		FLG[7] = ON
	ENDIF
	
ENDFOR
	
FOR i = 1 TO n DO
	-- WRITE log('Struct ', i, CR)
	-- WRITE log('	x:', structs[i].x, CR)
	-- WRITE log('	y:', structs[i].y, CR)
	-- WRITE log('	dist_2d:', structs[i].dist_2d, CR)
	WRITE log('    id:', structs[i].id, CR)
	WRITE log('    x:', structs[i].x, CR)
	WRITE log('    y:', structs[i].y, CR)
	WRITE log('    z:', structs[i].z, CR)
	WRITE log('    w:', structs[i].w, CR)
	WRITE log('    p:', structs[i].p, CR)
	WRITE log('    r:', structs[i].r, CR)
	WRITE log('    rot_diff:', structs[i].rot_diff, CR)
ENDFOR


CLOSE FILE timeLog
logText('Client END')
END xml_client

ROUTINE set_reg_
BEGIN
			--set registers	
		SET_REAL_REG( R_COORD1, structs[1].x, STATUS)
		IF (STATUS <> 0 ) THEN
			RETURN (-1)
		ENDIF
	
		SET_REAL_REG( R_COORD2,  structs[1].y, STATUS)
		IF (STATUS <> 0 ) THEN
			RETURN (-1)
		ENDIF
	
		SET_REAL_REG( R_COORD3,  structs[1].z, STATUS)
		IF (STATUS <> 0 ) THEN
			RETURN (-1)
		ENDIF
	
		SET_REAL_REG( R_COORD4,  structs[1].w, STATUS)
		IF (STATUS <> 0 ) THEN
			RETURN (-1)
		ENDIF
	
		SET_REAL_REG( R_COORD5,  structs[1].p, STATUS)
		IF (STATUS <> 0 ) THEN
			RETURN (-1)
		ENDIF
	
		SET_REAL_REG( R_COORD6,  structs[1].r, STATUS)
		IF (STATUS <> 0 ) THEN
			RETURN (-1)
		ENDIF
		
		RETURN (STATUS)	
END set_reg_
	
