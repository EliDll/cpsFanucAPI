PROGRAM api_client

%NOLOCKGROUP
%NOPAUSE=ERROR+COMMAND+TPENABLE
%NOBUSYLAMP

	%INCLUDE types
	%INCLUDE klerxmlf


CONST
	PROGRAM_NAME = 'api_client'
	-- global ID's of buffer variables below
	PP_BUFFER_NAME = 'pp_buffer'
	OBJ_BUFFER_NAME = 'obj_buffer'
	pipe_path = 'PIP:pipe.dt'
	CONNECTION_TAG = 'C3:'
	
	relative_pos = FALSE
	
	PR_XYZWPR = 41
	
	mm_err_margin = 2
	angle_err_margin = 2

VAR
	-- buffers for xml_scan, it needs static variable name as parameter
	obj_buffer: picking_object_t
	pp_buffer: picking_point_t

	obj_array: ARRAY [16] OF picking_object_t
	pp_array: ARRAY [16] OF picking_point_t

	-- storage of target selection
	target_obj_id: STRING[32]
	target_pp_id: STRING[32]

	STATUS: INTEGER

	-- file declarations must be global
	-- socket file for REST calls
	socket_file: FILE
	-- output file for REST calls
	pipe_file: FILE
	
	-- log output
	time_rtt: INTEGER
	time_xml: INTEGER
	time_total: INTEGER

	i: INTEGER
	n: INTEGER
	
	current_pos: XYZWPR
	target_pos: XYZWPR
	
	-- variable declarations for API calls
	pp_query_keys: ARRAY[8] OF STRING[32]
	pp_query_values: ARRAY[8] OF STRING[32]
	query: STRING[254]
	query_success: BOOLEAN
	
-- standalone imports
%INCLUDE util/generic_util

-- requires log_util
%INCLUDE util/socket_util
%INCLUDE util/file_util
%INCLUDE util/stopwatch_util
%INCLUDE xml/obj_parser	
%INCLUDE xml/pp_parser

-- requires socket_util, file_util
%INCLUDE util/rest_util

BEGIN

-- set system vars for some reason
$GROUP[1].$UTOOL = $MNUTOOL[1,1] --uTool 1
$GROUP[1].$UFRAME = $MNUFRAME[1,1] --uFrame 1

-- reset in case previous execution was faulty
ABORT_TASK('motion', TRUE, TRUE, STATUS)
DISCONNECT_FROM_SERVER(CONNECTION_TAG, socket_file)

current_pos = CURPOS(0,0)
current_pos.x = current_pos.x + 5
current_pos.y = current_pos.y + 5
current_pos.z = current_pos.z + 5
current_pos.w = current_pos.w + 5
current_pos.p = current_pos.p + 5
current_pos.r = current_pos.r + 5

SET_POS_REG(40, current_pos, STATUS)

RUN_TASK( 'static_track', 1, FALSE, TRUE, 1 OR 2 OR 4, STATUS ) -- queue motion task
DELAY(1000)
SET_VAR(0, '*SYSTEM*', '$DPM_SCH[1].$GRP[1].$OFS[1].$INI_OFS', 5.0, STATUS)
SET_VAR(0, '*SYSTEM*', '$DPM_SCH[1].$GRP[1].$OFS[2].$INI_OFS', 5.0, STATUS)
SET_VAR(0, '*SYSTEM*', '$DPM_SCH[1].$GRP[1].$OFS[3].$INI_OFS', 5.0, STATUS)
WRITE (STATUS, CR)
DELAY(1000)
SET_VAR(0, '*SYSTEM*', '$DPM_SCH[1].$GRP[1].$OFS[1].$INI_OFS', -5.0, STATUS)
SET_VAR(0, '*SYSTEM*', '$DPM_SCH[1].$GRP[1].$OFS[2].$INI_OFS', -5.0, STATUS)
SET_VAR(0, '*SYSTEM*', '$DPM_SCH[1].$GRP[1].$OFS[3].$INI_OFS', -5.0, STATUS)
DELAY(1000)

RETURN

---------------------------
-- Fetch picking objects
---------------------------

query = 'GET /fieldview/objects'

START_TIME(time_rtt)
MAKE_REST_CALL(query,CONNECTION_TAG, socket_file, pipe_file, pipe_path)


START_TIME(time_xml)
n = PARSE_OBJ_LIST(pipe_file, pipe_path, obj_buffer, OBJ_BUFFER_NAME, PROGRAM_NAME, obj_array)


IF(n = 0) THEN

	RETURN
ENDIF


-- TODO arbitrarily choose last
target_obj_id = obj_array[n].id

---------------------------
-- Fetch picking points
---------------------------

pp_query_keys[1] = 'obj_id'
pp_query_keys[2] = 'relative'
pp_query_keys[3] = 'x'
pp_query_keys[4] = 'y'
pp_query_keys[5] = 'z'
pp_query_keys[6] = 'w'
pp_query_keys[7] = 'p'
pp_query_keys[8] = 'r'

current_pos = CURPOS(0,0)
pp_query_values[1] = target_obj_id
pp_query_values[2] = BOOL_TO_STR(relative_pos)
pp_query_values[3] = REAL_TO_STR(current_pos.x)
pp_query_values[4] = REAL_TO_STR(current_pos.y)
pp_query_values[5] = REAL_TO_STR(current_pos.z)
pp_query_values[6] = REAL_TO_STR(current_pos.w)
pp_query_values[7] = REAL_TO_STR(current_pos.p)
pp_query_values[8] = REAL_TO_STR(current_pos.r)

-- 'GET /picking-points?obj_id=0&relative=0&x=0&y=0&z=0&w=0&p=0&r=0'
query = BUILD_PARAM_REQUEST('GET', 'fieldview/picking-points', pp_query_keys, pp_query_values)

START_TIME(time_rtt)
MAKE_REST_CALL(query,CONNECTION_TAG, socket_file, pipe_file, pipe_path)


START_TIME(time_xml)
n = PARSE_PP_LIST(pipe_file, pipe_path, pp_buffer, PP_BUFFER_NAME, PROGRAM_NAME, pp_array)


IF(n = 0) THEN

	RETURN
ENDIF

-- arbitrarily choose last
target_pp_id = pp_array[n].id

-- set target position
target_pos = current_pos
target_pos.x =  pp_array[n].x
target_pos.y =  pp_array[n].y
target_pos.z = pp_array[n].z
target_pos.w = pp_array[n].w
target_pos.p = pp_array[n].p
target_pos.r =  pp_array[n].r
START_TIME(time_total)

REPEAT
	---------------------------
	-- Track selected picking point
	---------------------------

	RUN_TASK( 'motion', 1, FALSE, TRUE, 1 OR 2 OR 4, STATUS ) -- queue motion task

	SET_POS_REG(PR_XYZWPR, target_pos, STATUS)	-- set positions register
	IF (STATUS <> 0 ) THEN		

	ELSE

		FLG[4] = ON						
		FLG[7] = ON
	ENDIF
	-- TODO polling interval
	DELAY(1000)
	ABORT_TASK('motion', TRUE, TRUE, STATUS) -- terminate motion task & associated movement
	START_TIME(time_total)

	-- other query keys remain the same for this endpoint
	pp_query_keys[1] = 'pp_id'

	-- update query parameters
	current_pos = CURPOS(0,0)
	pp_query_values[1] = target_pp_id
	pp_query_values[2] = BOOL_TO_STR(relative_pos)
	pp_query_values[3] = REAL_TO_STR(current_pos.x)
	pp_query_values[4] = REAL_TO_STR(current_pos.y)
	pp_query_values[5] = REAL_TO_STR(current_pos.z)
	pp_query_values[6] = REAL_TO_STR(current_pos.w)
	pp_query_values[7] = REAL_TO_STR(current_pos.p)
	pp_query_values[8] = REAL_TO_STR(current_pos.r)
	
	-- 'GET /picking-points?pp_id=0&relative=0&x=0&y=0&z=0&w=0&p=0&r=0'
	query = BUILD_PARAM_REQUEST('GET', 'fieldview/track-picking-point', pp_query_keys, pp_query_values)
	
	START_TIME(time_rtt)
	MAKE_REST_CALL(query,CONNECTION_TAG, socket_file, pipe_file, pipe_path)

	
	START_TIME(time_xml)
	query_success = PARSE_PP_SINGLE(pipe_file, pipe_path, pp_buffer, PP_BUFFER_NAME, PROGRAM_NAME)

	IF(NOT query_success) THEN

		RETURN
	ENDIF

	-- set target position
	target_pos = current_pos
	target_pos.x =  pp_buffer.x
	target_pos.y =  pp_buffer.y
	target_pos.z = pp_buffer.z
	target_pos.w = pp_buffer.w
	target_pos.p = pp_buffer.p
	target_pos.r = pp_buffer.r
UNTIL (FALSE)

END api_client
