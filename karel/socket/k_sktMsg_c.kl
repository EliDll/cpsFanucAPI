PROGRAM k_sktMsg_c

%NOLOCKGROUP
%NOBUSYLAMP

TYPE
    picking_point = STRUCTURE
        picker_position: XYZWPR
    ENDSTRUCTURE

VAR
	connFile : FILE
	pipeFile : FILE
	STATUS : INTEGER

	-- only for debug printing the saved pipeFile
	printStr : String[40]
	count : INTEGER

%INCLUDE ../util/util

ROUTINE connectServ(serverTag : STRING)
BEGIN
	MSG_DISCO(serverTag, STATUS)
	MSG_CONNECT(serverTag, STATUS)

	checkError('Connecting to Server', STATUS)

	-- Open File
	OPEN FILE connFile('RW', serverTag)

	STATUS = IO_STATUS(connFile)

	checkError('Opening File.', STATUS)
END connectServ

ROUTINE requestData(file_path : STRING) : INTEGER
VAR
	nBytes : INTEGER
	serverMsg : STRING[254]
BEGIN
	WRITE connFile('GET /robot_position/?format=json', CR, CR)
	REPEAT
		BYTES_AHEAD(connFile, nBytes, STATUS)           
		IF STATUS <> 0 THEN
			RETURN (-1)
		ENDIF
		DELAY 100
	UNTIL nBytes > 0
	
	OPEN FILE pipeFile('RW', file_path)
	STATUS = IO_STATUS(pipeFile)
	checkError('Opening pipeFile', STATUS)

	WHILE nBytes > 0 DO
		READ connFile(serverMsg::nBytes)
		STATUS = IO_STATUS(connFile)

		checkError('I/O_Status (File)', STATUS)

		--wrapPrint(serverMsg)
		WRITE pipeFile(serverMsg)
		
		BYTES_AHEAD(connFile, nBytes, STATUS)           
		IF STATUS <> 0 THEN
			CLOSE FILE pipeFile
			RETURN (-1)
		ENDIF
		
	ENDWHILE
	CLOSE FILE pipeFile
	RETURN (0)
END requestData

ROUTINE parseJsonFile(pipeFile : FILE; text_index: INTEGER)
VAR
	status: INTEGER
	count: INTEGER
	read_str: STRING[100]
	-- old function input 
	x : REAL
	y : REAL
	z : REAL
	w : REAL
	p : REAL
	r : REAL
	c : STRING[1]
	c_1 : STRING[1]
	string_value : STRING[20]
	key_pointer : INTEGER
	searching : BOOLEAN
	candidate : STRING[3]
	loop1 : BOOLEAN
	reading : BOOLEAN
	v : REAL
	ret_val : picking_point
BEGIN
	BYTES_AHEAD(pipeFile, count, status)
	checkError('Bytes Ahead 0', status)

	WRITE('initial count ', count, CR)

	IF count > 0 THEN
		READ pipeFile(c::1)
	ENDIF
	
	BYTES_AHEAD(pipeFile, count, STATUS)
	WRITE('final count ', count, CR)
	WRITE('c ', c, CR)

	-- old function

	searching = FALSE
	key_pointer = 0
	candidate = ''
	loop1 = TRUE
	reading = FALSE
	string_value = ''
	-- -- prints for testing
	WRITE('text_index', text_index, CR)
	
	WHILE loop1 = TRUE DO
	-- c = SUB_STR(original_text, text_index, 1)
	READ pipeFile(c::1)
	BYTES_AHEAD(pipeFile, count, STATUS)

	IF (c <> '[') AND (c <> '{') THEN
		searching = TRUE
	ENDIF
	-- text_index = text_index + 1
	IF searching = TRUE THEN
		IF ((((key_pointer = 0) OR (key_pointer=2)) AND (c = '"')) OR ((key_pointer = 1) AND ((c = 'x') OR (c='y')))) THEN
					candidate = candidate + c
					WRITE('candidate=', candidate, CR)
					key_pointer = key_pointer + 1
		ELSE
			candidate = ''
			key_pointer = 0
		ENDIF
	-- begin testing
		IF key_pointer = 3 THEN
			searching = FALSE
			loop1 = FALSE
		ENDIF
	-- end testing 
	-- 	IF key_pointer = 3 THEN
	-- 		searching = FALSE
	-- 		key_pointer = 0
	-- 		c_1 = SUB_STR(candidate, 2, 1)
	-- 	ENDIF
	-- -- ELSE -- this guy
	-- 		--IF c = ':' THEN
	-- 		--  reading = TRUE
	-- 		-- ENDIF
	-- 		-- IF ((c = ',') OR (c = '}')) THEN
	-- 			searching = TRUE
	-- 			reading = FALSE
	-- 		--	WRITE('testone')
	-- 		--	WRITE('c1=', c_1, CR)
	-- 		--	WRITE('string_value=', string_value, CR)
	-- 		--	candidate = ''
	-- 		-- ENDIF
	-- 		IF c = '}' THEN
	-- 			loop1 = FALSE
	-- 		ENDIF
	ENDIF
	ENDWHILE
END parseJsonFile
   
BEGIN
	connectServ('C3:')
	STATUS  = requestData('PIP:read.dt')
	checkError('requestData', STATUS)
	CLOSE FILE connFile

	-- debug printing the saved pipeFile
	OPEN FILE pipeFile('RO', 'PIP:read.dt')
	STATUS = IO_STATUS(pipeFile)
	checkError('Open pipeFile', STATUS)
	
	SET_FILE_ATR(pipeFile, ATR_PIPWAIT, WAIT_USED) -- force READS to wait
	SET_FILE_ATR(pipeFile, ATR_TIMEOUT, (1*1000))  -- READs timeout after 1*1000ms
	
	--SET_FILE_POS(pipeFile, 400, STATUS)
	--checkError('set pos', STATUS)

	--  WHILE count > 0 DO
	--  	IF count >= 40 THEN
	--  		READ pipeFile(printStr::40)
	--  		WRITE(printStr, CR)
	--  	ELSE
	-- 		READ pipeFile(printStr::count)
	-- 		printStr = SUB_STR(printStr, 1, count)
	-- 		WRITE(printStr, CR)
	--  	ENDIF
	
	-- 	BYTES_AHEAD(pipeFile, count, STATUS)
	--  	checkError('Bytes Ahead 1', STATUS)
	
	--  ENDWHILE
	
	parseJsonFile(pipeFile, 1)
		

END k_sktMsg_c
